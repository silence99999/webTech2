{"version":3,"file":"index.js","names":["ok: boolean","error: any","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fetchOptions?: RequestInit","fields: readonly [...T]"],"sources":["../src/constants.ts","../src/helpers.ts","../src/functions/getCountries.ts","../src/functions/getCountriesByCodes.ts","../src/functions/getCountriesByCurrency.ts","../src/functions/getCountriesByLang.ts","../src/functions/getCountriesByName.ts","../src/functions/getCountriesByRegion.ts","../src/functions/getCountriesBySubregion.ts","../src/functions/getCountryByCapital.ts","../src/functions/getCountryByCode.ts","../src/functions/getCountryByDemonym.ts","../src/functions/getCountryByTranslation.ts","../src/index.ts"],"sourcesContent":["export const API_BASE_URL = \"https://restcountries.com/v3.1\";\n//\n","import { API_BASE_URL } from \"./constants\";\nimport { routes } from \"./data/api-routes\";\nimport { Country } from \"./types\";\n\ntype Route = (typeof routes)[number];\nexport type ConstructAPI = {\n  route?: Route;\n  query?: string;\n  fields?: readonly (keyof Country)[] | undefined;\n  status?: boolean;\n  codes?: string;\n  fullText?: boolean;\n};\n\nexport function constructAPI({ route = \"all\", query = \"\", fields, status, codes, fullText }: ConstructAPI) {\n  const base_url = new URL(API_BASE_URL);\n  if (status !== undefined) route = \"independent\";\n\n  base_url.pathname += `/${route}` + `/${query.toLowerCase()}`;\n  if (status !== undefined) base_url.searchParams.set(\"status\", String(status));\n  if (fullText !== undefined) base_url.searchParams.set(\"fullText\", String(fullText));\n  if (codes) base_url.searchParams.append(\"codes\", codes.toLowerCase());\n  fields = Array.from(new Set(fields));\n  if (fields && fields.length) base_url.searchParams.set(\"fields\", fields.join(\",\"));\n  return base_url;\n}\n\nexport function handleNotFoundError(ok: boolean) {\n  if (!ok)\n    console.error(\n      \"Couldn't find any country that matches your query, if you think it is issue please submit it via github issues\"\n    );\n}\n\nexport function handleNetworkError(error: any) {\n  console.warn(\"A network or REST Countries API side error happened while fetching data. Try again later.\");\n  console.warn(\n    \"If this error persists, please verify the status of the REST Countries API. If the issue continues, feel free to report it on GitHub: https://github.com/yusifaliyevpro/countries\"\n  );\n  console.error(error);\n}\n","import { constructAPI, handleNetworkError, handleNotFoundError } from \"../helpers\";\nimport { Country, CountryPicker } from \"../types\";\n\n/**\n * Fetches all countries, optionally filtered by independence status,\n * and including only the specified fields.\n *\n * > **Note:** The `fields` parameter is required and you can only specify upto 10 fields,\n * as mandated by Alejandro Matos See: {@link https://gitlab.com/restcountries/restcountries/-/issues/265}.\n *\n * @param params - An object containing:\n *   - `fields`: A required array of field names (keys from the `Country` type) to include in the response.\n *   - `independent`: If true, only includes independent countries; if false, only dependent ones.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to an array of `CountryPicker<T>` objects with the requested fields,\n *          or `null` if the request fails or no countries match the criteria.\n *\n * @example\n * // Get all countries with only the `name` and `area` fields\n * const countries = await getCountries({ fields: [\"name\", \"area\"] });\n *\n * @example\n * // Get all independent countries with only the `name` and `area` fields\n * const independentCountries = await getCountries({\n *   independent: true,\n *   fields: [\"name\", \"area\"]\n * });\n */\nexport async function getCountries<T extends readonly (keyof Country)[] & { length: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 }>(\n  { independent, fields }: { independent?: boolean; fields: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T>[] | null> {\n  try {\n    if (fields.length > 10) console.error(\"You can specify up to 10 fields only\");\n    const api = constructAPI({ status: independent, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    handleNotFoundError(response.ok);\n    return response.ok ? await response.json() : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker } from \"../types\";\nimport { Code } from \"../types/common\";\n\n/**\n * Fetches countries by their codes (e.g., CCA2, CCA3, or CIOC), optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n *\n * @param params - An object containing:\n *   - `codes`: An array of country codes to fetch data for. CCA3 is recommended for precision.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to an array of `CountryPicker<T>` objects with the requested fields,\n *          or `null` if the request fails or the countries are not found.\n *\n * @example\n * // Get countries by CCA3 codes with only `name` and `flags` fields\n * const countries = await getCountriesByCodes({\n *   codes: [\"USA\", \"FRA\", \"JPN\"],\n *   fields: [\"name\", \"flags\"]\n * });\n *\n * @example\n * // Get countries by CCA2 codes with all fields\n * const countries = await getCountriesByCodes({ codes: [\"US\", \"FR\", \"JP\"] });\n */\nexport async function getCountriesByCodes<T extends readonly (keyof Country)[]>(\n  { codes, fields }: { codes: Code[]; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T>[] | null> {\n  try {\n    const api = constructAPI({ route: \"alpha\", codes: codes.join(\",\"), fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? await response.json() : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker, Currency } from \"../types\";\n\n/**\n * Fetches countries that use the specified currency, optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n *\n * @param params - An object containing:\n *   - `currency`: The currency code (e.g., \"USD\", \"EUR\", \"JPY\") used to filter countries.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to an array of `CountryPicker<T>` objects with the requested fields,\n *          or `null` if the request fails or no countries use the specified currency.\n *\n * @example\n * // Get countries using the Euro with only `name` and `flags` fields\n * const euroCountries = await getCountriesByCurrency({\n *   currency: \"EUR\",\n *   fields: [\"name\", \"flags\"]\n * });\n *\n * @example\n * // Get countries using the Japanese Yen with all fields\n * const yenCountries = await getCountriesByCurrency({ currency: \"JPY\" });\n */\nexport async function getCountriesByCurrency<T extends readonly (keyof Country)[]>(\n  { currency, fields }: { currency: Currency; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T>[] | null> {\n  try {\n    const api = constructAPI({ route: \"currency\", query: currency as string, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? await response.json() : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker, Lang } from \"../types\";\n\n/**\n * Fetches countries where the specified language is officially or widely spoken,\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n *\n * @param params - An object containing:\n *   - `lang`: (e.g., \"Spanish\", \"English\", \"Azerbaijani\").\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to an array of `CountryPicker<T>` objects with the requested fields,\n *          or `null` if the request fails or no countries match the language criteria.\n *\n * @example\n * // Get countries where Spanish is spoken with `name` and `region` fields\n * const spanishSpeakingCountries = await getCountriesByLang({\n *   lang: \"spa\",\n *   fields: [\"name\", \"region\"]\n * });\n *\n * @example\n * // Get countries where English is spoken with all fields\n * const englishSpeakingCountries = await getCountriesByLang({ lang: \"en\" });\n */\nexport async function getCountriesByLang<T extends readonly (keyof Country)[]>(\n  { lang, fields }: { lang: Lang; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T>[] | null> {\n  try {\n    const api = constructAPI({ route: \"lang\", query: lang as string, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? await response.json() : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker } from \"../types\";\n\n/**\n * Fetches countries that match a given name or partial name,\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n * > Set `fullText` to `true` to require an exact, full-name match.\n *\n * @param params - An object containing:\n *   - `name`: The country name or partial name to search for (e.g., \"united\").\n *   - `fullText`: Optional boolean to indicate whether to match full names exactly.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to an array of `CountryPicker<T>` objects with the requested fields,\n *          or `null` if the request fails or no countries match the name.\n *\n * @example\n * // Search countries containing \"united\" with only `name` and `flags` fields\n * const results = await getCountriesByName({\n *   name: \"united\",\n *   fields: [\"name\", \"flags\"]\n * });\n *\n * @example\n * // Search for exact match of \"Finland\" with all fields\n * const country = await getCountriesByName({ name: \"Finland\", fullText: true });\n */\nexport async function getCountriesByName<T extends readonly (keyof Country)[]>(\n  { name, fullText, fields }: { name: string; fullText?: boolean; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T>[] | null> {\n  try {\n    const api = constructAPI({ route: \"name\", query: name, fields, fullText });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? await response.json() : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError, handleNotFoundError } from \"../helpers\";\nimport { Country, CountryPicker, Region } from \"../types\";\n\n/**\n * Fetches countries which belong to the specified world region,\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n *\n * @param params - An object containing:\n *   - `region`: The name of the region (e.g., \"Asia\", \"Europe\", \"Africa\") to filter countries by.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to an array of `CountryPicker<T>` objects with the requested fields,\n *          or `null` if the request fails or the region is not found.\n *\n * @example\n * // Get Asian countries with only `name` and `population` fields\n * const asianCountries = await getCountriesByRegion({\n *   region: \"Asia\",\n *   fields: [\"name\", \"population\"]\n * });\n *\n * @example\n * // Get all fields for countries in Europe\n * const europeanCountries = await getCountriesByRegion({ region: \"Europe\" });\n */\nexport async function getCountriesByRegion<T extends readonly (keyof Country)[]>(\n  { region, fields }: { region: Region; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T>[] | null> {\n  try {\n    const api = constructAPI({ route: \"region\", query: region, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    handleNotFoundError(response.ok);\n    return response.ok ? await response.json() : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker, Subregion } from \"../types\";\n\n/**\n * Fetches countries that belong to the specified subregion,\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n *\n * @param params - An object containing:\n *   - `subregion`: The subregion name (e.g., \"Southern Asia\", \"Northern Europe\") to filter countries by.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to an array of `CountryPicker<T>` objects with the requested fields,\n *          or `null` if the request fails or no countries match the subregion.\n *\n * @example\n * // Get countries in Northern Europe with only `name` and `population` fields\n * const nordicCountries = await getCountriesBySubregion({\n *   subregion: \"Northern Europe\",\n *   fields: [\"name\", \"population\"]\n * });\n *\n * @example\n * // Get all fields for countries in Southern Asia\n * const southAsianCountries = await getCountriesBySubregion({ subregion: \"Southern Asia\" });\n */\nexport async function getCountriesBySubregion<T extends readonly (keyof Country)[]>(\n  { subregion, fields }: { subregion: Subregion; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T>[] | null> {\n  try {\n    const api = constructAPI({ route: \"subregion\", query: subregion as string, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? await response.json() : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Capital, Country, CountryPicker } from \"../types\";\n\n/**\n * Fetches a single country by its capital city,\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n * > Returns the first matching country or `null` if none is found.\n *\n * @param params - An object containing:\n *   - `capital`: The name of the capital city to search for.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to a single `CountryPicker<T>` object with the requested fields,\n *          or `null` if the request fails or no country matches the capital city.\n *\n * @example\n * // Get country by capital \"Paris\" with only `name` and `region` fields\n * const country = await getCountryByCapital({\n *   capital: \"Paris\",\n *   fields: [\"name\", \"region\"]\n * });\n *\n * @example\n * // Get all fields for the country with capital \"Tokyo\"\n * const japan = await getCountryByCapital({ capital: \"Tokyo\" });\n */\nexport async function getCountryByCapital<T extends readonly (keyof Country)[]>(\n  { capital, fields }: { capital: Capital; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T> | null> {\n  try {\n    const api = constructAPI({ route: \"capital\", query: capital as string, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? (await response.json())[0] : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker } from \"../types\";\nimport { Code } from \"../types/common\";\n\n/**\n * Fetches a single country by its code (e.g., CCA2, CCA3, or CIOC),\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n * > Returns the first matching country or `null` if none is found.\n *\n * @param params - An object containing:\n *   - `code`: The country code to fetch data for. CCA3 is recommended for precision.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to a single `CountryPicker<T>` object with the requested fields,\n *          or `null` if the request fails or no country matches the code.\n *\n * @example\n * // Get country by CCA3 code \"USA\" with only `name` and `flags` fields\n * const usa = await getCountryByCode({\n *   code: \"USA\",\n *   fields: [\"name\", \"flags\"]\n * });\n *\n * @example\n * // Get all fields for the country with code \"FRA\"\n * const france = await getCountryByCode({ code: \"FRA\" });\n */\nexport async function getCountryByCode<T extends readonly (keyof Country)[]>(\n  { code, fields }: { code: Code; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T> | null> {\n  try {\n    const api = constructAPI({ route: \"alpha\", query: code as string, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    const data = await response.json();\n    return response.ok ? (fields && !!fields.length ? data : data[0]) : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker } from \"../types\";\n\n/**\n * Fetches a single country by its demonym (the name for its residents),\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n * > Returns the first matching country or `null` if none is found.\n *\n * @param params - An object containing:\n *   - `demonym`: The demonym string to search for (e.g., \"American\", \"French\").\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to a single `CountryPicker<T>` object with the requested fields,\n *          or `null` if the request fails or no country matches the demonym.\n *\n * @example\n * // Get country by demonym \"Canadian\" with only `name` and `region` fields\n * const canada = await getCountryByDemonym({\n *   demonym: \"Canadian\",\n *   fields: [\"name\", \"region\"]\n * });\n *\n * @example\n * // Get all fields for the country with demonym \"Brazilian\"\n * const brazil = await getCountryByDemonym({ demonym: \"Brazilian\" });\n */\nexport async function getCountryByDemonym<T extends readonly (keyof Country)[]>(\n  { demonym, fields }: { demonym: string; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T> | null> {\n  try {\n    const api = constructAPI({ route: \"demonym\", query: demonym, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? (await response.json())[0] : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { constructAPI, handleNetworkError } from \"../helpers\";\nimport { Country, CountryPicker } from \"../types\";\n\n/**\n * Fetches a single country by a translated country name,\n * optionally including only the specified fields.\n *\n * > **Note:** If `fields` is not provided, all available fields will be returned.\n * > Returns the first matching country or `null` if none is found.\n *\n * @param params - An object containing:\n *   - `translation`: The translated name of the country to search for.\n *   - `fields`: An optional array of field names (keys from the `Country` type) to include in the response.\n *\n * @param fetchOptions - Optional `RequestInit` object to customize the `fetch` request.\n *\n * @returns A promise that resolves to a single `CountryPicker<T>` object with the requested fields,\n *          or `null` if the request fails or no country matches the translation.\n *\n * @example\n * // Get country by translation \"Alemania\" (German for Germany) with only `name` and `region` fields\n * const germany = await getCountryByTranslation({\n *   translation: \"Alemania\",\n *   fields: [\"name\", \"region\"]\n * });\n *\n * @example\n * // Get all fields for the country with translation \"Espagne\" (French for Spain)\n * const spain = await getCountryByTranslation({ translation: \"Espagne\" });\n */\nexport async function getCountryByTranslation<T extends readonly (keyof Country)[]>(\n  { translation, fields }: { translation: string; fields?: T },\n  fetchOptions?: RequestInit\n): Promise<CountryPicker<T> | null> {\n  try {\n    const api = constructAPI({ route: \"translation\", query: translation, fields });\n    const response = await fetch(api.toString(), fetchOptions);\n    return response.ok ? (await response.json())[0] : null;\n  } catch (error) {\n    handleNetworkError(error);\n    return null;\n  }\n}\n","import { Country } from \"./types\";\n// import { getCountries } from \"./functions/getCountries\";\n\nexport const defineFields = <T extends (keyof Country)[]>(fields: readonly [...T]) => fields;\n\nexport { getCountries } from \"./functions/getCountries\";\nexport { getCountriesByCodes } from \"./functions/getCountriesByCodes\";\nexport { getCountriesByCurrency } from \"./functions/getCountriesByCurrency\";\nexport { getCountriesByLang } from \"./functions/getCountriesByLang\";\nexport { getCountriesByName } from \"./functions/getCountriesByName\";\nexport { getCountriesByRegion } from \"./functions/getCountriesByRegion\";\nexport { getCountriesBySubregion } from \"./functions/getCountriesBySubregion\";\nexport { getCountryByCapital } from \"./functions/getCountryByCapital\";\nexport { getCountryByCode } from \"./functions/getCountryByCode\";\nexport { getCountryByDemonym } from \"./functions/getCountryByDemonym\";\nexport { getCountryByTranslation } from \"./functions/getCountryByTranslation\";\n"],"mappings":"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"}